{"version":3,"names":[],"sources":["../../../src/ast-types/generated/index.ts"],"sourcesContent":["// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/ast-types.js for script used.\n\ninterface BaseComment {\n  value: string;\n  start?: number;\n  end?: number;\n  loc?: SourceLocation;\n  // generator will skip the comment if ignore is true\n  ignore?: boolean;\n  type: \"CommentBlock\" | \"CommentLine\";\n}\n\nexport interface CommentBlock extends BaseComment {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends BaseComment {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\nexport interface SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ninterface BaseNode {\n  type: Node[\"type\"];\n  leadingComments?: Comment[] | null;\n  innerComments?: Comment[] | null;\n  trailingComments?: Comment[] | null;\n  start?: number | null;\n  end?: number | null;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n  extra?: Record<string, unknown>;\n}\n\nexport type CommentTypeShorthand = \"leading\" | \"inner\" | \"trailing\";\n\nexport type Node =\n  | AnyTypeAnnotation\n  | ArgumentPlaceholder\n  | ArrayExpression\n  | ArrayPattern\n  | ArrayTypeAnnotation\n  | ArrowFunctionExpression\n  | AssignmentExpression\n  | AssignmentPattern\n  | AwaitExpression\n  | BigIntLiteral\n  | BinaryExpression\n  | BindExpression\n  | BlockStatement\n  | BooleanLiteral\n  | BooleanLiteralTypeAnnotation\n  | BooleanTypeAnnotation\n  | BreakStatement\n  | CallExpression\n  | CatchClause\n  | ClassAccessorProperty\n  | ClassBody\n  | ClassDeclaration\n  | ClassExpression\n  | ClassImplements\n  | ClassMethod\n  | ClassPrivateMethod\n  | ClassPrivateProperty\n  | ClassProperty\n  | ConditionalExpression\n  | ContinueStatement\n  | DebuggerStatement\n  | DecimalLiteral\n  | DeclareClass\n  | DeclareExportAllDeclaration\n  | DeclareExportDeclaration\n  | DeclareFunction\n  | DeclareInterface\n  | DeclareModule\n  | DeclareModuleExports\n  | DeclareOpaqueType\n  | DeclareTypeAlias\n  | DeclareVariable\n  | DeclaredPredicate\n  | Decorator\n  | Directive\n  | DirectiveLiteral\n  | DoExpression\n  | DoWhileStatement\n  | EmptyStatement\n  | EmptyTypeAnnotation\n  | EnumBooleanBody\n  | EnumBooleanMember\n  | EnumDeclaration\n  | EnumDefaultedMember\n  | EnumNumberBody\n  | EnumNumberMember\n  | EnumStringBody\n  | EnumStringMember\n  | EnumSymbolBody\n  | ExistsTypeAnnotation\n  | ExportAllDeclaration\n  | ExportDefaultDeclaration\n  | ExportDefaultSpecifier\n  | ExportNamedDeclaration\n  | ExportNamespaceSpecifier\n  | ExportSpecifier\n  | ExpressionStatement\n  | File\n  | ForInStatement\n  | ForOfStatement\n  | ForStatement\n  | FunctionDeclaration\n  | FunctionExpression\n  | FunctionTypeAnnotation\n  | FunctionTypeParam\n  | GenericTypeAnnotation\n  | Identifier\n  | IfStatement\n  | Import\n  | ImportAttribute\n  | ImportDeclaration\n  | ImportDefaultSpecifier\n  | ImportNamespaceSpecifier\n  | ImportSpecifier\n  | IndexedAccessType\n  | InferredPredicate\n  | InterfaceDeclaration\n  | InterfaceExtends\n  | InterfaceTypeAnnotation\n  | InterpreterDirective\n  | IntersectionTypeAnnotation\n  | JSXAttribute\n  | JSXClosingElement\n  | JSXClosingFragment\n  | JSXElement\n  | JSXEmptyExpression\n  | JSXExpressionContainer\n  | JSXFragment\n  | JSXIdentifier\n  | JSXMemberExpression\n  | JSXNamespacedName\n  | JSXOpeningElement\n  | JSXOpeningFragment\n  | JSXSpreadAttribute\n  | JSXSpreadChild\n  | JSXText\n  | LabeledStatement\n  | LogicalExpression\n  | MemberExpression\n  | MetaProperty\n  | MixedTypeAnnotation\n  | ModuleExpression\n  | NewExpression\n  | Noop\n  | NullLiteral\n  | NullLiteralTypeAnnotation\n  | NullableTypeAnnotation\n  | NumberLiteral\n  | NumberLiteralTypeAnnotation\n  | NumberTypeAnnotation\n  | NumericLiteral\n  | ObjectExpression\n  | ObjectMethod\n  | ObjectPattern\n  | ObjectProperty\n  | ObjectTypeAnnotation\n  | ObjectTypeCallProperty\n  | ObjectTypeIndexer\n  | ObjectTypeInternalSlot\n  | ObjectTypeProperty\n  | ObjectTypeSpreadProperty\n  | OpaqueType\n  | OptionalCallExpression\n  | OptionalIndexedAccessType\n  | OptionalMemberExpression\n  | ParenthesizedExpression\n  | PipelineBareFunction\n  | PipelinePrimaryTopicReference\n  | PipelineTopicExpression\n  | Placeholder\n  | PrivateName\n  | Program\n  | QualifiedTypeIdentifier\n  | RecordExpression\n  | RegExpLiteral\n  | RegexLiteral\n  | RestElement\n  | RestProperty\n  | ReturnStatement\n  | SequenceExpression\n  | SpreadElement\n  | SpreadProperty\n  | StaticBlock\n  | StringLiteral\n  | StringLiteralTypeAnnotation\n  | StringTypeAnnotation\n  | Super\n  | SwitchCase\n  | SwitchStatement\n  | SymbolTypeAnnotation\n  | TSAnyKeyword\n  | TSArrayType\n  | TSAsExpression\n  | TSBigIntKeyword\n  | TSBooleanKeyword\n  | TSCallSignatureDeclaration\n  | TSConditionalType\n  | TSConstructSignatureDeclaration\n  | TSConstructorType\n  | TSDeclareFunction\n  | TSDeclareMethod\n  | TSEnumDeclaration\n  | TSEnumMember\n  | TSExportAssignment\n  | TSExpressionWithTypeArguments\n  | TSExternalModuleReference\n  | TSFunctionType\n  | TSImportEqualsDeclaration\n  | TSImportType\n  | TSIndexSignature\n  | TSIndexedAccessType\n  | TSInferType\n  | TSInstantiationExpression\n  | TSInterfaceBody\n  | TSInterfaceDeclaration\n  | TSIntersectionType\n  | TSIntrinsicKeyword\n  | TSLiteralType\n  | TSMappedType\n  | TSMethodSignature\n  | TSModuleBlock\n  | TSModuleDeclaration\n  | TSNamedTupleMember\n  | TSNamespaceExportDeclaration\n  | TSNeverKeyword\n  | TSNonNullExpression\n  | TSNullKeyword\n  | TSNumberKeyword\n  | TSObjectKeyword\n  | TSOptionalType\n  | TSParameterProperty\n  | TSParenthesizedType\n  | TSPropertySignature\n  | TSQualifiedName\n  | TSRestType\n  | TSStringKeyword\n  | TSSymbolKeyword\n  | TSThisType\n  | TSTupleType\n  | TSTypeAliasDeclaration\n  | TSTypeAnnotation\n  | TSTypeAssertion\n  | TSTypeLiteral\n  | TSTypeOperator\n  | TSTypeParameter\n  | TSTypeParameterDeclaration\n  | TSTypeParameterInstantiation\n  | TSTypePredicate\n  | TSTypeQuery\n  | TSTypeReference\n  | TSUndefinedKeyword\n  | TSUnionType\n  | TSUnknownKeyword\n  | TSVoidKeyword\n  | TaggedTemplateExpression\n  | TemplateElement\n  | TemplateLiteral\n  | ThisExpression\n  | ThisTypeAnnotation\n  | ThrowStatement\n  | TopicReference\n  | TryStatement\n  | TupleExpression\n  | TupleTypeAnnotation\n  | TypeAlias\n  | TypeAnnotation\n  | TypeCastExpression\n  | TypeParameter\n  | TypeParameterDeclaration\n  | TypeParameterInstantiation\n  | TypeofTypeAnnotation\n  | UnaryExpression\n  | UnionTypeAnnotation\n  | UpdateExpression\n  | V8IntrinsicIdentifier\n  | VariableDeclaration\n  | VariableDeclarator\n  | Variance\n  | VoidTypeAnnotation\n  | WhileStatement\n  | WithStatement\n  | YieldExpression;\n\nexport interface ArrayExpression extends BaseNode {\n  type: \"ArrayExpression\";\n  elements: Array<null | Expression | SpreadElement>;\n}\n\nexport interface AssignmentExpression extends BaseNode {\n  type: \"AssignmentExpression\";\n  operator: string;\n  left: LVal;\n  right: Expression;\n}\n\nexport interface BinaryExpression extends BaseNode {\n  type: \"BinaryExpression\";\n  operator:\n    | \"+\"\n    | \"-\"\n    | \"/\"\n    | \"%\"\n    | \"*\"\n    | \"**\"\n    | \"&\"\n    | \"|\"\n    | \">>\"\n    | \">>>\"\n    | \"<<\"\n    | \"^\"\n    | \"==\"\n    | \"===\"\n    | \"!=\"\n    | \"!==\"\n    | \"in\"\n    | \"instanceof\"\n    | \">\"\n    | \"<\"\n    | \">=\"\n    | \"<=\"\n    | \"|>\";\n  left: Expression | PrivateName;\n  right: Expression;\n}\n\nexport interface InterpreterDirective extends BaseNode {\n  type: \"InterpreterDirective\";\n  value: string;\n}\n\nexport interface Directive extends BaseNode {\n  type: \"Directive\";\n  value: DirectiveLiteral;\n}\n\nexport interface DirectiveLiteral extends BaseNode {\n  type: \"DirectiveLiteral\";\n  value: string;\n}\n\nexport interface BlockStatement extends BaseNode {\n  type: \"BlockStatement\";\n  body: Array<Statement>;\n  directives: Array<Directive>;\n}\n\nexport interface BreakStatement extends BaseNode {\n  type: \"BreakStatement\";\n  label?: Identifier | null;\n}\n\nexport interface CallExpression extends BaseNode {\n  type: \"CallExpression\";\n  callee: Expression | Super | V8IntrinsicIdentifier;\n  arguments: Array<\n    Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder\n  >;\n  optional?: true | false | null;\n  typeArguments?: TypeParameterInstantiation | null;\n  typeParameters?: TSTypeParameterInstantiation | null;\n}\n\nexport interface CatchClause extends BaseNode {\n  type: \"CatchClause\";\n  param?: Identifier | ArrayPattern | ObjectPattern | null;\n  body: BlockStatement;\n}\n\nexport interface ConditionalExpression extends BaseNode {\n  type: \"ConditionalExpression\";\n  test: Expression;\n  consequent: Expression;\n  alternate: Expression;\n}\n\nexport interface ContinueStatement extends BaseNode {\n  type: \"ContinueStatement\";\n  label?: Identifier | null;\n}\n\nexport interface DebuggerStatement extends BaseNode {\n  type: \"DebuggerStatement\";\n}\n\nexport interface DoWhileStatement extends BaseNode {\n  type: \"DoWhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n\nexport interface EmptyStatement extends BaseNode {\n  type: \"EmptyStatement\";\n}\n\nexport interface ExpressionStatement extends BaseNode {\n  type: \"ExpressionStatement\";\n  expression: Expression;\n}\n\nexport interface File extends BaseNode {\n  type: \"File\";\n  program: Program;\n  comments?: Array<CommentBlock | CommentLine> | null;\n  tokens?: Array<any> | null;\n}\n\nexport interface ForInStatement extends BaseNode {\n  type: \"ForInStatement\";\n  left: VariableDeclaration | LVal;\n  right: Expression;\n  body: Statement;\n}\n\nexport interface ForStatement extends BaseNode {\n  type: \"ForStatement\";\n  init?: VariableDeclaration | Expression | null;\n  test?: Expression | null;\n  update?: Expression | null;\n  body: Statement;\n}\n\nexport interface FunctionDeclaration extends BaseNode {\n  type: \"FunctionDeclaration\";\n  id?: Identifier | null;\n  params: Array<Identifier | Pattern | RestElement>;\n  body: BlockStatement;\n  generator: boolean;\n  async: boolean;\n  declare?: boolean | null;\n  predicate?: DeclaredPredicate | InferredPredicate | null;\n  returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface FunctionExpression extends BaseNode {\n  type: \"FunctionExpression\";\n  id?: Identifier | null;\n  params: Array<Identifier | Pattern | RestElement>;\n  body: BlockStatement;\n  generator: boolean;\n  async: boolean;\n  predicate?: DeclaredPredicate | InferredPredicate | null;\n  returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface Identifier extends BaseNode {\n  type: \"Identifier\";\n  name: string;\n  decorators?: Array<Decorator> | null;\n  optional?: boolean | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n}\n\nexport interface IfStatement extends BaseNode {\n  type: \"IfStatement\";\n  test: Expression;\n  consequent: Statement;\n  alternate?: Statement | null;\n}\n\nexport interface LabeledStatement extends BaseNode {\n  type: \"LabeledStatement\";\n  label: Identifier;\n  body: Statement;\n}\n\nexport interface StringLiteral extends BaseNode {\n  type: \"StringLiteral\";\n  value: string;\n}\n\nexport interface NumericLiteral extends BaseNode {\n  type: \"NumericLiteral\";\n  value: number;\n}\n\n/**\n * @deprecated Use `NumericLiteral`\n */\nexport interface NumberLiteral extends BaseNode {\n  type: \"NumberLiteral\";\n  value: number;\n}\n\nexport interface NullLiteral extends BaseNode {\n  type: \"NullLiteral\";\n}\n\nexport interface BooleanLiteral extends BaseNode {\n  type: \"BooleanLiteral\";\n  value: boolean;\n}\n\nexport interface RegExpLiteral extends BaseNode {\n  type: \"RegExpLiteral\";\n  pattern: string;\n  flags: string;\n}\n\n/**\n * @deprecated Use `RegExpLiteral`\n */\nexport interface RegexLiteral extends BaseNode {\n  type: \"RegexLiteral\";\n  pattern: string;\n  flags: string;\n}\n\nexport interface LogicalExpression extends BaseNode {\n  type: \"LogicalExpression\";\n  operator: \"||\" | \"&&\" | \"??\";\n  left: Expression;\n  right: Expression;\n}\n\nexport interface MemberExpression extends BaseNode {\n  type: \"MemberExpression\";\n  object: Expression | Super;\n  property: Expression | Identifier | PrivateName;\n  computed: boolean;\n  optional?: true | false | null;\n}\n\nexport interface NewExpression extends BaseNode {\n  type: \"NewExpression\";\n  callee: Expression | Super | V8IntrinsicIdentifier;\n  arguments: Array<\n    Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder\n  >;\n  optional?: true | false | null;\n  typeArguments?: TypeParameterInstantiation | null;\n  typeParameters?: TSTypeParameterInstantiation | null;\n}\n\nexport interface Program extends BaseNode {\n  type: \"Program\";\n  body: Array<Statement>;\n  directives: Array<Directive>;\n  sourceType: \"script\" | \"module\";\n  interpreter?: InterpreterDirective | null;\n  sourceFile: string;\n}\n\nexport interface ObjectExpression extends BaseNode {\n  type: \"ObjectExpression\";\n  properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;\n}\n\nexport interface ObjectMethod extends BaseNode {\n  type: \"ObjectMethod\";\n  kind: \"method\" | \"get\" | \"set\";\n  key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral;\n  params: Array<Identifier | Pattern | RestElement>;\n  body: BlockStatement;\n  computed: boolean;\n  generator: boolean;\n  async: boolean;\n  decorators?: Array<Decorator> | null;\n  returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface ObjectProperty extends BaseNode {\n  type: \"ObjectProperty\";\n  key:\n    | Expression\n    | Identifier\n    | StringLiteral\n    | NumericLiteral\n    | BigIntLiteral\n    | DecimalLiteral\n    | PrivateName;\n  value: Expression | PatternLike;\n  computed: boolean;\n  shorthand: boolean;\n  decorators?: Array<Decorator> | null;\n}\n\nexport interface RestElement extends BaseNode {\n  type: \"RestElement\";\n  argument: LVal;\n  decorators?: Array<Decorator> | null;\n  optional?: boolean | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n}\n\n/**\n * @deprecated Use `RestElement`\n */\nexport interface RestProperty extends BaseNode {\n  type: \"RestProperty\";\n  argument: LVal;\n  decorators?: Array<Decorator> | null;\n  optional?: boolean | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n}\n\nexport interface ReturnStatement extends BaseNode {\n  type: \"ReturnStatement\";\n  argument?: Expression | null;\n}\n\nexport interface SequenceExpression extends BaseNode {\n  type: \"SequenceExpression\";\n  expressions: Array<Expression>;\n}\n\nexport interface ParenthesizedExpression extends BaseNode {\n  type: \"ParenthesizedExpression\";\n  expression: Expression;\n}\n\nexport interface SwitchCase extends BaseNode {\n  type: \"SwitchCase\";\n  test?: Expression | null;\n  consequent: Array<Statement>;\n}\n\nexport interface SwitchStatement extends BaseNode {\n  type: \"SwitchStatement\";\n  discriminant: Expression;\n  cases: Array<SwitchCase>;\n}\n\nexport interface ThisExpression extends BaseNode {\n  type: \"ThisExpression\";\n}\n\nexport interface ThrowStatement extends BaseNode {\n  type: \"ThrowStatement\";\n  argument: Expression;\n}\n\nexport interface TryStatement extends BaseNode {\n  type: \"TryStatement\";\n  block: BlockStatement;\n  handler?: CatchClause | null;\n  finalizer?: BlockStatement | null;\n}\n\nexport interface UnaryExpression extends BaseNode {\n  type: \"UnaryExpression\";\n  operator: \"void\" | \"throw\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"~\" | \"typeof\";\n  argument: Expression;\n  prefix: boolean;\n}\n\nexport interface UpdateExpression extends BaseNode {\n  type: \"UpdateExpression\";\n  operator: \"++\" | \"--\";\n  argument: Expression;\n  prefix: boolean;\n}\n\nexport interface VariableDeclaration extends BaseNode {\n  type: \"VariableDeclaration\";\n  kind: \"var\" | \"let\" | \"const\";\n  declarations: Array<VariableDeclarator>;\n  declare?: boolean | null;\n}\n\nexport interface VariableDeclarator extends BaseNode {\n  type: \"VariableDeclarator\";\n  id: LVal;\n  init?: Expression | null;\n  definite?: boolean | null;\n}\n\nexport interface WhileStatement extends BaseNode {\n  type: \"WhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n\nexport interface WithStatement extends BaseNode {\n  type: \"WithStatement\";\n  object: Expression;\n  body: Statement;\n}\n\nexport interface AssignmentPattern extends BaseNode {\n  type: \"AssignmentPattern\";\n  left:\n    | Identifier\n    | ObjectPattern\n    | ArrayPattern\n    | MemberExpression\n    | TSAsExpression\n    | TSTypeAssertion\n    | TSNonNullExpression;\n  right: Expression;\n  decorators?: Array<Decorator> | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n}\n\nexport interface ArrayPattern extends BaseNode {\n  type: \"ArrayPattern\";\n  elements: Array<null | PatternLike | LVal>;\n  decorators?: Array<Decorator> | null;\n  optional?: boolean | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n}\n\nexport interface ArrowFunctionExpression extends BaseNode {\n  type: \"ArrowFunctionExpression\";\n  params: Array<Identifier | Pattern | RestElement>;\n  body: BlockStatement | Expression;\n  async: boolean;\n  expression: boolean;\n  generator?: boolean;\n  predicate?: DeclaredPredicate | InferredPredicate | null;\n  returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface ClassBody extends BaseNode {\n  type: \"ClassBody\";\n  body: Array<\n    | ClassMethod\n    | ClassPrivateMethod\n    | ClassProperty\n    | ClassPrivateProperty\n    | ClassAccessorProperty\n    | TSDeclareMethod\n    | TSIndexSignature\n    | StaticBlock\n  >;\n}\n\nexport interface ClassExpression extends BaseNode {\n  type: \"ClassExpression\";\n  id?: Identifier | null;\n  superClass?: Expression | null;\n  body: ClassBody;\n  decorators?: Array<Decorator> | null;\n  implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;\n  mixins?: InterfaceExtends | null;\n  superTypeParameters?:\n    | TypeParameterInstantiation\n    | TSTypeParameterInstantiation\n    | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface ClassDeclaration extends BaseNode {\n  type: \"ClassDeclaration\";\n  id: Identifier;\n  superClass?: Expression | null;\n  body: ClassBody;\n  decorators?: Array<Decorator> | null;\n  abstract?: boolean | null;\n  declare?: boolean | null;\n  implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;\n  mixins?: InterfaceExtends | null;\n  superTypeParameters?:\n    | TypeParameterInstantiation\n    | TSTypeParameterInstantiation\n    | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface ExportAllDeclaration extends BaseNode {\n  type: \"ExportAllDeclaration\";\n  source: StringLiteral;\n  assertions?: Array<ImportAttribute> | null;\n  exportKind?: \"type\" | \"value\" | null;\n}\n\nexport interface ExportDefaultDeclaration extends BaseNode {\n  type: \"ExportDefaultDeclaration\";\n  declaration:\n    | TSDeclareFunction\n    | FunctionDeclaration\n    | ClassDeclaration\n    | Expression;\n  exportKind?: \"value\" | null;\n}\n\nexport interface ExportNamedDeclaration extends BaseNode {\n  type: \"ExportNamedDeclaration\";\n  declaration?: Declaration | null;\n  specifiers: Array<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >;\n  source?: StringLiteral | null;\n  assertions?: Array<ImportAttribute> | null;\n  exportKind?: \"type\" | \"value\" | null;\n}\n\nexport interface ExportSpecifier extends BaseNode {\n  type: \"ExportSpecifier\";\n  local: Identifier;\n  exported: Identifier | StringLiteral;\n  exportKind?: \"type\" | \"value\" | null;\n}\n\nexport interface ForOfStatement extends BaseNode {\n  type: \"ForOfStatement\";\n  left: VariableDeclaration | LVal;\n  right: Expression;\n  body: Statement;\n  await: boolean;\n}\n\nexport interface ImportDeclaration extends BaseNode {\n  type: \"ImportDeclaration\";\n  specifiers: Array<\n    ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier\n  >;\n  source: StringLiteral;\n  assertions?: Array<ImportAttribute> | null;\n  importKind?: \"type\" | \"typeof\" | \"value\" | null;\n}\n\nexport interface ImportDefaultSpecifier extends BaseNode {\n  type: \"ImportDefaultSpecifier\";\n  local: Identifier;\n}\n\nexport interface ImportNamespaceSpecifier extends BaseNode {\n  type: \"ImportNamespaceSpecifier\";\n  local: Identifier;\n}\n\nexport interface ImportSpecifier extends BaseNode {\n  type: \"ImportSpecifier\";\n  local: Identifier;\n  imported: Identifier | StringLiteral;\n  importKind?: \"type\" | \"typeof\" | \"value\" | null;\n}\n\nexport interface MetaProperty extends BaseNode {\n  type: \"MetaProperty\";\n  meta: Identifier;\n  property: Identifier;\n}\n\nexport interface ClassMethod extends BaseNode {\n  type: \"ClassMethod\";\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\";\n  key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression;\n  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;\n  body: BlockStatement;\n  computed: boolean;\n  static: boolean;\n  generator: boolean;\n  async: boolean;\n  abstract?: boolean | null;\n  access?: \"public\" | \"private\" | \"protected\" | null;\n  accessibility?: \"public\" | \"private\" | \"protected\" | null;\n  decorators?: Array<Decorator> | null;\n  optional?: boolean | null;\n  override?: boolean;\n  returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface ObjectPattern extends BaseNode {\n  type: \"ObjectPattern\";\n  properties: Array<RestElement | ObjectProperty>;\n  decorators?: Array<Decorator> | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n}\n\nexport interface SpreadElement extends BaseNode {\n  type: \"SpreadElement\";\n  argument: Expression;\n}\n\n/**\n * @deprecated Use `SpreadElement`\n */\nexport interface SpreadProperty extends BaseNode {\n  type: \"SpreadProperty\";\n  argument: Expression;\n}\n\nexport interface Super extends BaseNode {\n  type: \"Super\";\n}\n\nexport interface TaggedTemplateExpression extends BaseNode {\n  type: \"TaggedTemplateExpression\";\n  tag: Expression;\n  quasi: TemplateLiteral;\n  typeParameters?:\n    | TypeParameterInstantiation\n    | TSTypeParameterInstantiation\n    | null;\n}\n\nexport interface TemplateElement extends BaseNode {\n  type: \"TemplateElement\";\n  value: { raw: string; cooked?: string };\n  tail: boolean;\n}\n\nexport interface TemplateLiteral extends BaseNode {\n  type: \"TemplateLiteral\";\n  quasis: Array<TemplateElement>;\n  expressions: Array<Expression | TSType>;\n}\n\nexport interface YieldExpression extends BaseNode {\n  type: \"YieldExpression\";\n  argument?: Expression | null;\n  delegate: boolean;\n}\n\nexport interface AwaitExpression extends BaseNode {\n  type: \"AwaitExpression\";\n  argument: Expression;\n}\n\nexport interface Import extends BaseNode {\n  type: \"Import\";\n}\n\nexport interface BigIntLiteral extends BaseNode {\n  type: \"BigIntLiteral\";\n  value: string;\n}\n\nexport interface ExportNamespaceSpecifier extends BaseNode {\n  type: \"ExportNamespaceSpecifier\";\n  exported: Identifier;\n}\n\nexport interface OptionalMemberExpression extends BaseNode {\n  type: \"OptionalMemberExpression\";\n  object: Expression;\n  property: Expression | Identifier;\n  computed: boolean;\n  optional: boolean;\n}\n\nexport interface OptionalCallExpression extends BaseNode {\n  type: \"OptionalCallExpression\";\n  callee: Expression;\n  arguments: Array<\n    Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder\n  >;\n  optional: boolean;\n  typeArguments?: TypeParameterInstantiation | null;\n  typeParameters?: TSTypeParameterInstantiation | null;\n}\n\nexport interface ClassProperty extends BaseNode {\n  type: \"ClassProperty\";\n  key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression;\n  value?: Expression | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  decorators?: Array<Decorator> | null;\n  computed: boolean;\n  static: boolean;\n  abstract?: boolean | null;\n  accessibility?: \"public\" | \"private\" | \"protected\" | null;\n  declare?: boolean | null;\n  definite?: boolean | null;\n  optional?: boolean | null;\n  override?: boolean;\n  readonly?: boolean | null;\n  variance?: Variance | null;\n}\n\nexport interface ClassAccessorProperty extends BaseNode {\n  type: \"ClassAccessorProperty\";\n  key:\n    | Identifier\n    | StringLiteral\n    | NumericLiteral\n    | BigIntLiteral\n    | Expression\n    | PrivateName;\n  value?: Expression | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  decorators?: Array<Decorator> | null;\n  computed: boolean;\n  static: boolean;\n  abstract?: boolean | null;\n  accessibility?: \"public\" | \"private\" | \"protected\" | null;\n  declare?: boolean | null;\n  definite?: boolean | null;\n  optional?: boolean | null;\n  override?: boolean;\n  readonly?: boolean | null;\n  variance?: Variance | null;\n}\n\nexport interface ClassPrivateProperty extends BaseNode {\n  type: \"ClassPrivateProperty\";\n  key: PrivateName;\n  value?: Expression | null;\n  decorators?: Array<Decorator> | null;\n  static: boolean;\n  definite?: boolean | null;\n  readonly?: boolean | null;\n  typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  variance?: Variance | null;\n}\n\nexport interface ClassPrivateMethod extends BaseNode {\n  type: \"ClassPrivateMethod\";\n  kind: \"get\" | \"set\" | \"method\";\n  key: PrivateName;\n  params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;\n  body: BlockStatement;\n  static: boolean;\n  abstract?: boolean | null;\n  access?: \"public\" | \"private\" | \"protected\" | null;\n  accessibility?: \"public\" | \"private\" | \"protected\" | null;\n  async?: boolean;\n  computed?: boolean;\n  decorators?: Array<Decorator> | null;\n  generator?: boolean;\n  optional?: boolean | null;\n  override?: boolean;\n  returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;\n  typeParameters?:\n    | TypeParameterDeclaration\n    | TSTypeParameterDeclaration\n    | Noop\n    | null;\n}\n\nexport interface PrivateName extends BaseNode {\n  type: \"PrivateName\";\n  id: Identifier;\n}\n\nexport interface StaticBlock extends BaseNode {\n  type: \"StaticBlock\";\n  body: Array<Statement>;\n}\n\nexport interface AnyTypeAnnotation extends BaseNode {\n  type: \"AnyTypeAnnotation\";\n}\n\nexport interface ArrayTypeAnnotation extends BaseNode {\n  type: \"ArrayTypeAnnotation\";\n  elementType: FlowType;\n}\n\nexport interface BooleanTypeAnnotation extends BaseNode {\n  type: \"BooleanTypeAnnotation\";\n}\n\nexport interface BooleanLiteralTypeAnnotation extends BaseNode {\n  type: \"BooleanLiteralTypeAnnotation\";\n  value: boolean;\n}\n\nexport interface NullLiteralTypeAnnotation extends BaseNode {\n  type: \"NullLiteralTypeAnnotation\";\n}\n\nexport interface ClassImplements extends BaseNode {\n  type: \"ClassImplements\";\n  id: Identifier;\n  typeParameters?: TypeParameterInstantiation | null;\n}\n\nexport interface DeclareClass extends BaseNode {\n  type: \"DeclareClass\";\n  id: Identifier;\n  typeParameters?: TypeParameterDeclaration | null;\n  extends?: Array<InterfaceExtends> | null;\n  body: ObjectTypeAnnotation;\n  implements?: Array<ClassImplements> | null;\n 